<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Canvas Motion Tracker</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: sans-serif; overflow: hidden; }
        .ui { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; pointer-events: none; }
        #container { position: relative; width: 100vw; height: 100vh; }
        video { position: absolute; width: 100%; height: 100%; object-fit: contain; }
        #canvasOutput { position: absolute; width: 100%; height: 100%; object-fit: contain; pointer-events: none; }
        /* 右上のデバッグ表示 */
        #debugCanvas { position: absolute; top: 10px; right: 10px; width: 120px; height: 90px; border: 2px solid #0f0; background: #222; z-index: 100; }
        .controls { position: absolute; bottom: 20px; width: 100%; display: flex; flex-direction: column; align-items: center; z-index: 200; gap: 10px;}
        input[type=range] { width: 70%; }
        button { padding: 15px 30px; background: #0f0; color: #000; border: none; border-radius: 30px; font-weight: bold; }
    </style>
</head>
<body>

<div class="ui">
    <div id="status">カメラ起動中...</div>
    <div style="font-size: 11px; color: #0f0;">動くものに反応して軌跡を描きます</div>
</div>

<div id="container">
    <video id="video" playsinline muted></video>
    <canvas id="canvasOutput"></canvas>
    <canvas id="debugCanvas"></canvas>
</div>

<div class="controls">
    <span id="threshText">感度: 40</span>
    <input type="range" id="threshold" min="10" max="100" value="40">
    <button onclick="points = []">軌跡リセット</button>
</div>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvasOutput');
const debug = document.getElementById('debugCanvas');
const ctx = canvas.getContext('2d');
const dctx = debug.getContext('2d', { willReadFrequently: true });

let points = [];
let prevData = null;
let threshold = 40;

document.getElementById('threshold').oninput = (e) => {
    threshold = e.target.value;
    document.getElementById('threshText').innerText = `感度: ${threshold}`;
};

async function init() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: "environment", width: 640 } 
        });
        video.srcObject = stream;
        video.play();
        document.getElementById('status').innerText = "TRACKING ACTIVE";
        
        video.onloadedmetadata = () => {
            canvas.width = debug.width = video.videoWidth;
            canvas.height = debug.height = video.videoHeight;
            requestAnimationFrame(loop);
        };
    } catch (e) {
        alert("カメラが許可されていません");
    }
}

function loop() {
    // 1. デバッグ用Canvasに現在の映像を描写
    dctx.drawImage(video, 0, 0, debug.width, debug.height);
    const currentFrame = dctx.getImageData(0, 0, debug.width, debug.height);
    const pixels = currentFrame.data;

    if (prevData) {
        let sumX = 0, sumY = 0, count = 0;

        // 2. ピクセルごとに前フレームとの差分を計算
        for (let i = 0; i < pixels.length; i += 4) {
            const rDiff = Math.abs(pixels[i] - prevData[i]);
            const gDiff = Math.abs(pixels[i+1] - prevData[i+1]);
            const bDiff = Math.abs(pixels[i+2] - prevData[i+2]);
            const avgDiff = (rDiff + gDiff + bDiff) / 3;

            if (avgDiff > threshold) {
                // 差分が大きい場所を白く塗る（デバッグ用）
                pixels[i] = pixels[i+1] = pixels[i+2] = 255;
                
                // 重心を計算するための座標蓄積
                const x = (i / 4) % debug.width;
                const y = Math.floor((i / 4) / debug.width);
                sumX += x;
                sumY += y;
                count++;
            } else {
                // 変化がない場所は黒くする
                pixels[i] = pixels[i+1] = pixels[i+2] = 0;
            }
        }
        dctx.putImageData(currentFrame, 0, 0);

        // 3. 動体の中心点を保存
        if (count > 10 && count < 2000) { // 小さすぎるノイズと大きすぎる変化を無視
            points.push({ x: sumX / count, y: sumY / count, t: Date.now() });
        }
    }

    prevData = new Uint8ClampedArray(pixels);
    drawTrace();
    requestAnimationFrame(loop);
}

function drawTrace() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (points.length < 2) return;

    const now = Date.now();
    points = points.filter(p => now - p.t < 1200); // 1.2秒で消える

    ctx.strokeStyle = '#0f0';
    ctx.lineWidth = 5;
    ctx.lineCap = 'round';
    ctx.beginPath();

    for (let i = 1; i < points.length; i++) {
        const d = Math.hypot(points[i].x - points[i-1].x, points[i].y - points[i-1].y);
        if (d < 100) { // 離れすぎている点は結ばない
            ctx.moveTo(points[i-1].x, points[i-1].y);
            ctx.lineTo(points[i].x, points[i].y);
        }
    }
    ctx.stroke();
}

init();
</script>
</body>
</html>
