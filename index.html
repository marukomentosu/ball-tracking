<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Auto Motion Tracker</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: sans-serif; overflow: hidden; }
        .ui { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; border-left: 4px solid #f00; pointer-events: none; }
        #container { position: relative; width: 100vw; height: 100vh; }
        video, canvas { position: absolute; width: 100%; height: 100%; object-fit: contain; }
        canvas { mix-blend-mode: screen; }
        .controls { position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: center; z-index: 200; }
        button { padding: 15px 30px; background: #f00; color: #fff; border: none; border-radius: 50px; font-weight: bold; cursor: pointer; }
        #debugCanvas { position: absolute; top: 10px; right: 10px; width: 120px; height: 90px; border: 1px solid #555; z-index: 100; }
    </style>
</head>
<body>

<div class="ui">
    <div id="status">背景学習中...（カメラを固定してください）</div>
    <div id="info" style="font-size: 12px; color: #aaa; margin-top:5px;">高速な動きを自動検知して着色します</div>
</div>

<div id="container">
    <video id="videoInput" playsinline></video>
    <canvas id="canvasOutput"></canvas>
    <canvas id="debugCanvas"></canvas>
</div>

<div class="controls">
    <button onclick="clearTrace()">軌跡をリセット</button>
</div>

<script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady();"></script>

<script>
const video = document.getElementById('videoInput');
const canvas = document.getElementById('canvasOutput');
const debugCanvas = document.getElementById('debugCanvas');
const ctx = canvas.getContext('2d');
let trackPoints = [];
let isReady = false;

function onOpenCvReady() {
    startCamera();
}

async function startCamera() {
    const constraints = { video: { facingMode: "environment", width: 1280, height: 720 } };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    video.onloadedmetadata = () => {
        video.play();
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        isReady = true;
        processMotion();
    };
}

function processMotion() {
    // 背景差分アルゴリズムの初期化 (MOG2)
    let fgbg = new cv.BackgroundSubtractorMOG2(500, 16, true);
    let src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
    let fgmask = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);
    let cap = new cv.VideoCapture(video);

    function step() {
        if (!isReady) return;
        cap.read(src);

        // 背景差分を適用して動体マスクを作成
        fgbg.apply(src, fgmask);

        // ノイズ除去（小さい動きを消す）
        let M = cv.Mat.ones(3, 3, cv.CV_8U);
        cv.morphologyEx(fgmask, fgmask, cv.MORPH_OPEN, M);

        // デバッグ表示（何が動体として認識されているか）
        cv.imshow('debugCanvas', fgmask);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(fgmask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let detectedThisFrame = [];

        if (contours.size() > 0) {
            document.getElementById('status').innerText = "動体検知中...";
            for (let i = 0; i < contours.size(); ++i) {
                let area = cv.contourArea(contours.get(i));
                // 面積制限：ゴミ（小）や人間（大）を除外し、ボールサイズを狙う
                if (area > 10 && area < 2000) {
                    let rect = cv.boundingRect(contours.get(i));
                    let cx = rect.x + rect.width / 2;
                    let cy = rect.y + rect.height / 2;
                    
                    let velocity = 0;
                    if (trackPoints.length > 0) {
                        let last = trackPoints[trackPoints.length - 1];
                        velocity = Math.hypot(cx - last.x, cy - last.y);
                    }

                    // 高速移動しているもの（1フレームで5px以上）を優先
                    if (velocity > 5 || trackPoints.length === 0) {
                        trackPoints.push({x: cx, y: cy, v: velocity});
                    }
                }
            }
        }

        drawSpeedTrace();

        contours.delete(); hierarchy.delete(); M.delete();
        requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
}

function drawSpeedTrace() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (trackPoints.length < 2) return;

    // 軌跡が多すぎる場合に少しずつ消す（残像効果が欲しい場合はコメントアウト）
    if(trackPoints.length > 150) trackPoints.shift();

    for (let i = 1; i < trackPoints.length; i++) {
        let p1 = trackPoints[i-1];
        let p2 = trackPoints[i];

        // 速度による色分け（虹色グラデーション）
        // 0px:青(240) -> 50px:赤(0)
        let hue = Math.max(0, 240 - (p2.v * 5));
        ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.lineWidth = Math.min(15, 3 + p2.v / 4);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // 軌跡が離れすぎている（カットされた）場合は線を引かない
        if (p2.v < 300) {
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }
    }
}

function clearTrace() {
    trackPoints = [];
    document.getElementById('status').innerText = "背景再学習中...";
}
</script>
</body>
</html>
