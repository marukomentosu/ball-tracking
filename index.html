<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Tennis Tracker</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: sans-serif; overflow: hidden; }
        .ui { position: absolute; top: 10px; left: 10px; z-index: 10; pointer-events: none; }
        .btn-layer { position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: center; gap: 10px; z-index: 20; }
        button { pointer-events: auto; padding: 12px 20px; background: #222; color: #0f0; border: 1px solid #0f0; border-radius: 5px; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        video { position: absolute; width: 100%; height: 100%; object-fit: contain; }
        canvas { position: absolute; width: 100%; height: 100%; object-fit: contain; }
        #debugCanvas { position: absolute; top: 10px; right: 10px; width: 120px; height: 90px; border: 1px solid red; z-index: 100; background: #000; }
    </style>
</head>
<body>

<div class="ui">
    <div id="status">Loading OpenCV.js...</div>
    <div style="font-size: 10px;">ヒント: ボールが映ったらそこをタップして色を学習させてください</div>
</div>

<div id="container">
    <video id="videoInput" playsinline></video>
    <canvas id="canvasOutput"></canvas>
    <canvas id="debugCanvas"></canvas>
</div>

<div class="btn-layer">
    <button onclick="clearTrace()">軌跡リセット</button>
</div>

<script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady();"></script>

<script>
const video = document.getElementById('videoInput');
const canvas = document.getElementById('canvasOutput');
const debugCanvas = document.getElementById('debugCanvas');
const ctx = canvas.getContext('2d');
const dCtx = debugCanvas.getContext('2d');

let trackPoints = [];
let isReady = false;
let lowHsv = [0, 0, 180]; // 初期値：白っぽい色
let highHsv = [180, 60, 255];

function onOpenCvReady() {
    document.getElementById('status').innerText = '準備完了: 背面カメラ起動中...';
    startCamera();
}

async function startCamera() {
    const constraints = {
        video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }
    };
    try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        video.onloadedmetadata = () => {
            video.play();
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            debugCanvas.width = 160;
            debugCanvas.height = 120;
            isReady = true;
            processVideo();
        };
    } catch (e) {
        document.getElementById('status').innerText = 'カメラエラー: ' + e.message;
    }
}

// 画面をタップしてボールの色を取得する
window.addEventListener('touchstart', (e) => {
    if(!isReady) return;
    const rect = video.getBoundingClientRect();
    const touch = e.touches[0];
    const x = (touch.clientX - rect.left) * (video.videoWidth / rect.width);
    const y = (touch.clientY - rect.top) * (video.videoHeight / rect.height);
    pickColor(x, y);
});

function pickColor(x, y) {
    let tmpSrc = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
    let cap = new cv.VideoCapture(video);
    cap.read(tmpSrc);
    let hsv = new cv.Mat();
    cv.cvtColor(tmpSrc, hsv, cv.COLOR_RGBA2RGB);
    cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
    
    let pixel = hsv.ucharPtr(y, x);
    // タップした色の周辺範囲をターゲットにする
    lowHsv = [Math.max(0, pixel[0]-20), Math.max(0, pixel[1]-50), Math.max(0, pixel[2]-50)];
    highHsv = [Math.min(180, pixel[0]+20), Math.min(255, pixel[1]+70), Math.min(255, pixel[2]+70)];
    
    document.getElementById('status').innerText = '色をロックオンしました！';
    tmpSrc.delete(); hsv.delete();
}

function processVideo() {
    let src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
    let hsv = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC3);
    let mask = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);
    let cap = new cv.VideoCapture(video);

    function step() {
        if (!isReady) return;
        cap.read(src);
        cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
        cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);

        let low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [...lowHsv, 0]);
        let high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [...highHsv, 255]);
        
        cv.inRange(hsv, low, high, mask);

        // ノイズ消去
        let M = cv.Mat.ones(5, 5, cv.CV_8U);
        cv.morphologyEx(mask, mask, cv.MORPH_OPEN, M);

        // デバッグ表示（右上の小窓に抽出状態を表示）
        cv.imshow('debugCanvas', mask);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let found = false;
        if (contours.size() > 0) {
            let maxArea = 0;
            let bestIdx = -1;
            for (let i = 0; i < contours.size(); ++i) {
                let area = cv.contourArea(contours.get(i));
                if (area > 20 && area < 5000) { // ボールらしいサイズ
                    if (area > maxArea) {
                        maxArea = area;
                        bestIdx = i;
                    }
                }
            }
            if (bestIdx !== -1) {
                let rect = cv.boundingRect(contours.get(bestIdx));
                trackPoints.push({x: rect.x + rect.width/2, y: rect.y + rect.height/2});
                found = true;
            }
        }

        drawTrace();
        
        low.delete(); high.delete(); contours.delete(); hierarchy.delete(); M.delete();
        requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
}

function drawTrace() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (trackPoints.length < 2) return;

    ctx.strokeStyle = '#00FF00';
    ctx.lineWidth = 6;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#00FF00';

    ctx.beginPath();
    ctx.moveTo(trackPoints[0].x, trackPoints[0].y);
    for (let i = 1; i < trackPoints.length; i++) {
        ctx.lineTo(trackPoints[i].x, trackPoints[i].y);
    }
    ctx.stroke();
}

function clearTrace() {
    trackPoints = [];
}
</script>
</body>
</html>
