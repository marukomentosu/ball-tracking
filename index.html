<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>High-Visibility Tracker</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: sans-serif; overflow: hidden; }
        .ui { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 5px; border-left: 4px solid #ff0; pointer-events: none; }
        #container { position: relative; width: 100vw; height: 100vh; }
        video, canvas { position: absolute; width: 100%; height: 100%; object-fit: contain; }
        #debugCanvas { position: absolute; top: 10px; right: 10px; width: 160px; height: 120px; border: 2px solid #ff0; z-index: 100; background: #000; }
        .btn-layer { position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: center; z-index: 200; }
        button { padding: 15px 40px; background: #ff0; color: #000; border: none; border-radius: 50px; font-weight: bold; cursor: pointer; box-shadow: 0 0 20px rgba(255,255,0,0.5); }
    </style>
</head>
<body>

<div class="ui">
    <div id="status">OpenCV 読み込み中...</div>
    <div id="info" style="font-size: 11px; color: #ff0; margin-top:5px;">右上の窓に白い点が映るように動かしてください</div>
</div>

<div id="container">
    <video id="videoInput" playsinline></video>
    <canvas id="canvasOutput"></canvas>
    <canvas id="debugCanvas"></canvas>
</div>

<div class="btn-layer">
    <button onclick="clearTrace()">軌跡リセット</button>
</div>

<script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady();"></script>

<script>
const video = document.getElementById('videoInput');
const canvas = document.getElementById('canvasOutput');
const debugCanvas = document.getElementById('debugCanvas');
const ctx = canvas.getContext('2d');
let trackPoints = [];
let isReady = false;

function onOpenCvReady() {
    document.getElementById('status').innerText = "システム稼働中";
    startCamera();
}

async function startCamera() {
    const constraints = { video: { facingMode: "environment", width: 640, height: 480 } };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    video.onloadedmetadata = () => {
        video.play();
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        isReady = true;
        processFlow();
    };
}

function processFlow() {
    let cap = new cv.VideoCapture(video);
    let frame1 = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
    let prvs = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);
    let next = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);
    let diff = new cv.Mat();

    function step() {
        if (!isReady) return;
        cap.read(frame1);
        cv.cvtColor(frame1, next, cv.COLOR_RGBA2GRAY);

        if (prvs.empty()) {
            next.copyTo(prvs);
            requestAnimationFrame(step);
            return;
        }

        // フレーム間差分を計算
        cv.absdiff(next, prvs, diff);
        // 感度調整：25以上に変化があった場所を「動き」とみなす（値を下げると感度が上がります）
        cv.threshold(diff, diff, 25, 255, cv.THRESH_BINARY);
        
        // デバッグ窓に表示
        cv.imshow('debugCanvas', diff);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(diff, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let foundBall = false;
        if (contours.size() > 0) {
            let maxArea = 0;
            let bestPoint = null;

            for (let i = 0; i < contours.size(); ++i) {
                let area = cv.contourArea(contours.get(i));
                // 小さいゴミ（手ブレ）を無視し、ボール（一定以上の塊）を拾う
                if (area > 5 && area < 2000) {
                    let rect = cv.boundingRect(contours.get(i));
                    let cx = rect.x + rect.width / 2;
                    let cy = rect.y + rect.height / 2;
                    
                    if (area > maxArea) {
                        maxArea = area;
                        bestPoint = {x: cx, y: cy};
                    }
                }
            }

            if (bestPoint) {
                // 軌跡が飛んでしまわないよう、前回の点から「100px以内」なら繋ぐ、
                // あるいは「一定時間（10フレーム分）以上空いたら新しい線」とする処理
                trackPoints.push({
                    x: bestPoint.x, 
                    y: bestPoint.y, 
                    time: Date.now(),
                    speed: trackPoints.length > 0 ? Math.hypot(bestPoint.x - trackPoints[trackPoints.length-1].x, bestPoint.y - trackPoints[trackPoints.length-1].y) : 0
                });
                foundBall = true;
            }
        }

        drawTrace();
        next.copyTo(prvs);
        contours.delete(); hierarchy.delete();
        requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
}

function drawTrace() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (trackPoints.length < 2) return;

    // 1.5秒以上更新がない古い点は削除していく（自動リセット）
    const now = Date.now();
    trackPoints = trackPoints.filter(p => now - p.time < 1500);

    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    for (let i = 1; i < trackPoints.length; i++) {
        const p1 = trackPoints[i-1];
        const p2 = trackPoints[i];

        // 点の間隔が空きすぎていたら（別々の打球なら）線を引かない
        const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        if (dist > 300) continue; 

        const hue = Math.max(0, 60 - (p2.speed * 2)); // 黄色から赤へ変化
        ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.lineWidth = 6 + (p2.speed / 10);
        
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
    }
}

function clearTrace() {
    trackPoints = [];
}
</script>
</body>
</html>
