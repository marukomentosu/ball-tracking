<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soft Tennis Tracker Pro</title>
    <style>
        :root { --accent: #00FF00; }
        body { 
            margin: 0; font-family: -apple-system, sans-serif; 
            background: #000; color: white; 
            display: flex; flex-direction: column; align-items: center;
            touch-action: manipulation; /* ダブルタップズーム防止 */
        }
        .header { width: 100%; padding: 15px; text-align: center; background: #222; }
        .container { 
            position: relative; width: 100vw; max-width: 640px; 
            aspect-ratio: 4 / 3; background: #111;
        }
        video, canvas { 
            position: absolute; top: 0; left: 0; 
            width: 100% !important; height: auto !important; 
        }
        .controls { 
            padding: 20px; width: 90%; max-width: 600px;
            display: flex; gap: 10px; justify-content: center;
        }
        button { 
            flex: 1; padding: 12px; font-size: 16px; font-weight: bold;
            border: none; border-radius: 8px; background: var(--accent); color: black;
        }
        #status { font-size: 12px; color: #aaa; margin-top: 5px; }
    </style>
</head>
<body>

<div class="header">
    <strong>Soft Tennis Ball Tracker</strong>
    <div id="status">OpenCV.js 読込中...</div>
</div>

<div class="container">
    <video id="videoInput" playsinline></video>
    <canvas id="canvasOutput"></canvas>
</div>

<div class="controls">
    <button onclick="clearTrace()">軌跡をリセット</button>
</div>

<script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady();"></script>

<script>
const video = document.getElementById('videoInput');
const canvas = document.getElementById('canvasOutput');
const ctx = canvas.getContext('2d');
const statusText = document.getElementById('status');
let trackPoints = [];
let streaming = false;

function onOpenCvReady() {
    statusText.innerText = 'OpenCV 準備完了。カメラを起動します...';
    startCamera();
}

async function startCamera() {
    const constraints = {
        video: { 
            facingMode: { exact: "environment" }, // 背面カメラを優先
            width: { ideal: 640 },
            height: { ideal: 480 }
        },
        audio: false
    };

    try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        video.play();
    } catch (err) {
        console.warn("背面カメラが見つかりません。デフォルトカメラを使用します。", err);
        // 背面カメラがない（PCなど）場合のフォールバック
        const fallbackStream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = fallbackStream;
        video.play();
    }

    video.addEventListener("canplay", () => {
        if (!streaming) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            streaming = true;
            statusText.innerText = 'トラッキング中...';
            processVideo();
        }
    });
}

function processVideo() {
    let src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
    let hsv = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC3);
    let mask = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);
    let cap = new cv.VideoCapture(video);

    // ボール検知用HSV（白〜黄色）
    let low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 0, 180, 0]);
    let high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180, 60, 255, 255]);

    function process() {
        if (!streaming) return;
        try {
            cap.read(src);
            cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
            cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
            cv.inRange(hsv, low, high, mask);

            let M = cv.Mat.ones(3, 3, cv.CV_8U);
            cv.erode(mask, mask, M);
            cv.dilate(mask, mask, M);

            let contours = new cv.MatVector(); // 修正: 日本語変数を削除
            let hierarchy = new cv.Mat();
            cv.findContours(mask, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

            if (contours.size() > 0) {
                let maxArea = 0;
                let bestIdx = -1;
                for (let i = 0; i < contours.size(); ++i) {
                    let area = cv.contourArea(contours.get(i));
                    if (area > 30 && area < 5000) {
                        if (area > maxArea) {
                            maxArea = area;
                            bestIdx = i;
                        }
                    }
                }

                if (bestIdx !== -1) {
                    let circle = cv.minEnclosingCircle(contours.get(bestIdx));
                    trackPoints.push({x: circle.center.x, y: circle.center.y});
                    if(trackPoints.length > 100) trackPoints.shift(); // 古い軌跡を消す場合は有効化
                }
            }

            drawTrace();
            contours.delete();
            hierarchy.delete();
            requestAnimationFrame(process);
        } catch (err) {
            console.error(err);
        }
    }
    requestAnimationFrame(process);
}

function drawTrace() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (trackPoints.length < 2) return;

    ctx.beginPath();
    ctx.strokeStyle = '#00FF00';
    ctx.lineWidth = 5;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    
    ctx.moveTo(trackPoints[0].x, trackPoints[0].y);
    for (let i = 1; i < trackPoints.length; i++) {
        ctx.lineTo(trackPoints[i].x, trackPoints[i].y);
    }
    ctx.stroke();

    const last = trackPoints[trackPoints.length - 1];
    ctx.beginPath();
    ctx.arc(last.x, last.y, 8, 0, Math.PI * 2);
    ctx.fillStyle = '#FFFF00';
    ctx.fill();
}

function clearTrace() {
    trackPoints = [];
}
</script>
</body>
</html>
