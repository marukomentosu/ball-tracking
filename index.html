<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Light Tracker</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: sans-serif; overflow: hidden; }
        .ui { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; width: 200px; }
        #container { position: relative; width: 100vw; height: 100vh; }
        video, #canvasOutput { position: absolute; width: 100%; height: 100%; object-fit: contain; }
        #debugCanvas { position: absolute; top: 10px; right: 10px; width: 120px; height: 90px; border: 1px solid #f00; z-index: 100; }
        .controls { position: absolute; bottom: 20px; width: 100%; display: flex; flex-direction: column; align-items: center; gap: 10px; z-index: 200; }
        input[type=range] { width: 80%; }
        button { padding: 12px 30px; background: #f00; color: #fff; border: none; border-radius: 5px; font-weight: bold; }
    </style>
</head>
<body>

<div class="ui">
    <div id="status">OpenCV 準備中...</div>
    <div style="font-size: 10px; margin-top:5px;">
        1. 右上の窓が「真っ暗」なら感度を右へ<br>
        2. 「砂嵐」なら感度を左へ
    </div>
</div>

<div id="container">
    <video id="videoInput" playsinline muted></video>
    <canvas id="canvasOutput"></canvas>
    <canvas id="debugCanvas"></canvas>
</div>

<div class="controls">
    <span id="threshVal">感度しきい値: 20</span>
    <input type="range" id="threshold" min="5" max="100" value="20">
    <button onclick="clearTrace()">軌跡リセット</button>
</div>

<script async src="https://docs.opencv.org/4.5.4/opencv.js" onload="onOpenCvReady();"></script>

<script>
const video = document.getElementById('videoInput');
const canvas = document.getElementById('canvasOutput');
const debugCanvas = document.getElementById('debugCanvas');
const ctx = canvas.getContext('2d');
const threshSlider = document.getElementById('threshold');
const threshDisplay = document.getElementById('threshVal');

let trackPoints = [];
let isReady = false;

threshSlider.oninput = function() { threshDisplay.innerText = `感度しきい値: ${this.value}`; };

function onOpenCvReady() {
    document.getElementById('status').innerText = "READY (自動検知中)";
    startCamera();
}

async function startCamera() {
    // 処理を軽くするため、解像度をあえて低く（640x480）設定
    const constraints = { video: { facingMode: "environment", width: 640, height: 480 } };
    try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        video.play();
        video.onloadedmetadata = () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            isReady = true;
            processLoop();
        };
    } catch(e) { alert("カメラ起動失敗: " + e.message); }
}

function processLoop() {
    let cap = new cv.VideoCapture(video);
    let src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
    let gray = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);
    let prevGray = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);
    let diff = new cv.Mat();

    function step() {
        if (!isReady) return;
        cap.read(src);
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        if (prevGray.empty()) {
            gray.copyTo(prevGray);
            requestAnimationFrame(step);
            return;
        }

        // 前のフレームとの差分をとる
        cv.absdiff(gray, prevGray, diff);
        
        // スライダーの値でしきい値を決定
        let t = parseInt(threshSlider.value);
        cv.threshold(diff, diff, t, 255, cv.THRESH_BINARY);
        
        // 右上の窓に映す（これが真っ黒なら何も検知できていない）
        cv.imshow('debugCanvas', diff);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(diff, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        if (contours.size() > 0) {
            let maxArea = 0;
            let bestP = null;
            for (let i = 0; i < contours.size(); ++i) {
                let area = cv.contourArea(contours.get(i));
                // 小さすぎるゴミは無視、ある程度の塊（5〜500px）をボールとする
                if (area > 5 && area < 500) {
                    if (area > maxArea) {
                        maxArea = area;
                        let rect = cv.boundingRect(contours.get(i));
                        bestP = { x: rect.x + rect.width/2, y: rect.y + rect.height/2 };
                    }
                }
            }
            if (bestP) {
                trackPoints.push({ x: bestP.x, y: bestP.y, time: Date.now() });
            }
        }

        drawTrace();
        gray.copyTo(prevGray);
        contours.delete(); hierarchy.delete();
        requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
}

function drawTrace() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (trackPoints.length < 2) return;

    // 1秒以上前の軌跡は自動消去
    const now = Date.now();
    trackPoints = trackPoints.filter(p => now - p.time < 1000);

    ctx.strokeStyle = "#ff0"; // 軌跡を黄色に
    ctx.lineWidth = 5;
    ctx.lineCap = "round";
    ctx.beginPath();
    
    for (let i = 0; i < trackPoints.length; i++) {
        if (i === 0) ctx.moveTo(trackPoints[i].x, trackPoints[i].y);
        else {
            // 前の点と離れすぎていたら（ノイズ対策）線を引かない
            let d = Math.hypot(trackPoints[i].x - trackPoints[i-1].x, trackPoints[i].y - trackPoints[i-1].y);
            if (d < 150) ctx.lineTo(trackPoints[i].x, trackPoints[i].y);
            else ctx.moveTo(trackPoints[i].x, trackPoints[i].y);
        }
    }
    ctx.stroke();
}

function clearTrace() { trackPoints = []; }
</script>
</body>
</html>
